{"version":3,"sources":["ng://factor-auth/lib/auth.service.ts","ng://factor-auth/lib/auth.guard.ts","ng://factor-auth/lib/login.guard.ts","ng://factor-auth/lib/auth-interceptor.ts","ng://factor-auth/lib/auth.module.ts"],"names":["AuthService","prototype","checkLoggedIn","this","storageService","get","loggedInSource","next","loggedIn","getToken","login","form","_this","params","client_id","configuration","clientId","client_secret","clientSecret","grant_type","response_type","username","password","state","Date","now","http","post","tokenUrl","pipe","tap","token","set","logout","delete","refreshToken","url","refresh_token","Injectable","args","providedIn","HttpClient","StorageService","Inject","BehaviorSubject","asObservable","access_token","AuthGuard","canActivate","authService","LoginGuard","router","navigateByUrl","Router","AuthInterceptor","intercept","request","injector","handle","addAuthenticationToken","catchError","error","HttpErrorResponse","throwError","status","handle401Error","refreshTokenInProgress","refreshTokenSubject","filter","take","switchMap","newToken","share","finalize","includes","clone","setHeaders","Authorization","token_type","Injector","AuthModule","forRoot","ngModule","providers","provide","HTTP_INTERCEPTORS","useClass","multi","useValue","NgModule","declarations","imports","exports"],"mappings":"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","sourcesContent":["import { Inject, Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { tap } from 'rxjs/operators';\n\nimport { StorageService } from 'factor-utils';\n\nimport { Token } from './models/token';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n  private loggedInSource: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);\n  public loggedIn: Observable<boolean> = this.loggedInSource.asObservable();\n\n  constructor(\n    private http: HttpClient,\n    private storageService: StorageService,\n    @Inject('FactorAuthConfiguration') private configuration\n  ) {\n    if (this.getToken() && this.getToken().access_token) {\n      this.loggedInSource.next(true);\n    }\n  }\n\n  checkLoggedIn() {\n    if (this.storageService.get('token', 'local')) {\n      this.loggedInSource.next(true);\n    } else {\n      this.loggedInSource.next(false);\n    }\n    return this.loggedIn;\n  }\n  getToken(): Token {\n    return this.storageService.get('token', 'local');\n  }\n  login(form: { username: string, password: string }): Observable<Token> {\n    const params = {\n      client_id: this.configuration.clientId,\n      client_secret: this.configuration.clientSecret,\n      grant_type: 'password',\n      response_type: 'token',\n      username: form.username,\n      password: form.password,\n      state: Date.now()\n    };\n    return this.http.post(this.configuration.tokenUrl, params).pipe(tap((token: Token) => {\n      this.storageService.set('token', token, 'local');\n      this.loggedInSource.next(true);\n    }));\n  }\n  logout(): void {\n    this.storageService.delete('token', 'local');\n    this.loggedInSource.next(false);\n  }\n  refreshToken(): Observable<Token> {\n    const token = this.storageService.get('token', 'local');\n    const url = `${this.configuration.tokenUrl}`;\n    const params = {\n      client_id: this.configuration.clientId,\n      client_secret: this.configuration.clientSecret,\n      grant_type: 'refresh_token',\n      refresh_token: token.refresh_token\n    };\n    return this.http.get(url, { params: params }).pipe(tap((token: Token) => {\n      this.storageService.set('token', token, 'local');\n    }));\n  }\n}\n","\nimport { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n\n  constructor(\n    private authService: AuthService\n  ) { }\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {\n    if (this.authService.getToken()) {\n      //TODO Verify session on server with Observable\n      return true;\n    } else {\n      this.authService.logout();\n      return false;\n    }\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LoginGuard implements CanActivate {\n\n  constructor(\n    private authService: AuthService,\n    private router: Router\n  ) { }\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {\n    if (this.authService.getToken()) {\n      this.router.navigateByUrl('/');\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n","import { Injectable, Injector } from '@angular/core';\nimport { HttpHandler, HttpRequest, HttpErrorResponse, HttpSentEvent, HttpHeaderResponse, HttpProgressEvent, HttpResponse, HttpUserEvent } from '@angular/common/http';\nimport { Observable, BehaviorSubject, throwError } from 'rxjs';\nimport { catchError, filter, take, switchMap, finalize, share } from 'rxjs/operators';\n\nimport { AuthService } from './auth.service';\nimport { Token } from './models/token';\n\n@Injectable()\nexport class AuthInterceptor {\n  private authService: AuthService;\n  private refreshTokenInProgress = false;\n  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\n\n  constructor(\n    private injector: Injector\n  ) { }\n\n  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpSentEvent | HttpHeaderResponse | HttpProgressEvent | HttpResponse<any> | HttpUserEvent<any> | any> {\n    this.authService = this.injector.get(AuthService);\n    return next.handle(this.addAuthenticationToken(request)).pipe(\n      catchError(error => {\n        if (error instanceof HttpErrorResponse) {\n          switch ((<HttpErrorResponse>error).status) {\n            case 401:\n              return this.authService.getToken().refresh_token? this.handle401Error(request, next) : throwError(error);\n              break;\n            default:\n              return throwError(error);\n              break;\n          }\n        } else {\n          return throwError(error);\n        }\n      })\n    );\n  }\n  handle401Error(request: HttpRequest<any>, next: HttpHandler): Observable<any> {\n    if (!this.refreshTokenInProgress) {\n      this.refreshTokenInProgress = true;\n      this.refreshTokenSubject.next(null);\n      return this.authService.refreshToken().pipe(\n        switchMap((newToken: Token) => {\n          if (newToken) {\n            this.refreshTokenSubject.next(newToken);\n            return next.handle(this.addAuthenticationToken(request));\n          }\n\n          // If we don't get a new token, we are in trouble so logout.\n          this.authService.logout();\n          return throwError('');\n        }),\n        catchError(error => {\n          // If there is an exception calling 'refreshToken', bad news so logout.\n          this.authService.logout();\n          return throwError(error);\n        }),\n        share(),\n        finalize(() => {\n          this.refreshTokenInProgress = false;\n        }),\n      );\n    } else {\n      return this.refreshTokenSubject.pipe(\n        filter(token => token != null),\n        take(1),\n        switchMap(token => {\n          return next.handle(this.addAuthenticationToken(request));\n        })\n      );\n    }\n  }\n  addAuthenticationToken(request): HttpRequest<any> {\n    const token: Token = this.authService.getToken();\n\n    // If access token is null this means that user is not logged in\n    // And we return the original request\n    if (!token || request.url.includes(\"token\")) {\n      return request;\n    }\n\n    // We clone the request, because the original request is immutable\n    return request.clone({\n      setHeaders: {\n        Authorization: `${token.token_type} ${token.access_token}`\n      }\n    });\n  }\n\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nimport { AuthInterceptor } from './auth-interceptor';\n\n@NgModule({\n  declarations: [],\n  imports: [],\n  exports: []\n})\nexport class AuthModule {\n  public static forRoot(configuration: any): ModuleWithProviders {\n    return {\n      ngModule: AuthModule,\n      providers: [\n        { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },\n        { provide: 'FactorAuthConfiguration', useValue: configuration }\n      ]\n    };\n  }\n}\n"]}