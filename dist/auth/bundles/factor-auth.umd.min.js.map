{"version":3,"sources":["ng://factor-auth/lib/jwt.service.ts","ng://factor-auth/lib/oauth.service.ts","ng://factor-auth/lib/auth.service.ts","ng://factor-auth/lib/auth-interceptor.ts","ng://factor-auth/lib/auth.module.ts","ng://factor-auth/lib/auth.guard.ts","ng://factor-auth/lib/login.guard.ts"],"names":["JwtService","prototype","addAuthenticationToken","request","token","this","getToken","url","includes","clone","setHeaders","Authorization","checkLoggedIn","loggedInSource","next","loggedIn","storageService","get","tokenKey","login","data","_this","http","post","configuration","tokenUrl","pipe","tap","set","logout","delete","nosessionUrl","injector","Router","navigateByUrl","Injectable","args","providedIn","HttpClient","StorageService","Inject","Injector","BehaviorSubject","asObservable","OAuthService","token_type","access_token","handle401Error","refreshTokenInProgress","refreshTokenSubject","filter","take","switchMap","handle","refreshToken","newToken","throwError","catchError","error","share","finalize","form","params","client_id","clientId","client_secret","clientSecret","grant_type","response_type","username","password","state","Date","now","refresh_token","AuthService","getProvider","type","oauthService","jwtService","AuthInterceptor","intercept","authService","HttpErrorResponse","status","AuthModule","forRoot","ngModule","providers","provide","HTTP_INTERCEPTORS","useClass","multi","useValue","NgModule","declarations","imports","exports","AuthGuard","canActivate","LoginGuard","router"],"mappings":"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","sourcesContent":["import { Inject, Injectable, Injector } from '@angular/core';\nimport { HttpClient, HttpRequest, HttpHandler } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { tap } from 'rxjs/operators';\n\nimport { StorageService } from 'factor-utils';\n\nimport { AuthProvider } from './auth-provider';\nimport { Login } from './models/login';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class JwtService implements AuthProvider {\n  private loggedInSource: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);\n  public loggedIn: Observable<boolean> = this.loggedInSource.asObservable();\n  private tokenKey = 'auth_jwt';\n\n  constructor(\n    private http: HttpClient,\n    private storageService: StorageService,\n    @Inject('FactorAuthConfiguration') private configuration,\n    private injector: Injector\n  ) {\n    this.checkLoggedIn();\n  }\n\n  addAuthenticationToken(request: HttpRequest<any>): HttpRequest<any> {\n    const token: string = this.getToken();\n\n    // If access token is null this means that user is not logged in\n    // And we return the original request\n    if (!token || request.url.includes(\"token\")) {\n      return request;\n    }\n\n    // We clone the request, because the original request is immutable\n    return request.clone({\n      setHeaders: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n  }\n  checkLoggedIn(): Observable<boolean> {\n    if (this.getToken()) {\n      this.loggedInSource.next(true);\n    } else {\n      this.loggedInSource.next(false);\n    }\n    return this.loggedIn;\n  }\n  getToken(): string {\n    return this.storageService.get(this.tokenKey, 'local');\n  }\n  login(data: Login): Observable<any> {\n    return this.http.post(this.configuration.tokenUrl, data).pipe(tap((token: any) => {\n      this.storageService.set(this.tokenKey, token.token, 'local');\n      this.loggedInSource.next(true);\n    }));\n  }\n  logout(): void {\n    this.storageService.delete(this.tokenKey, 'local');\n    this.loggedInSource.next(false);\n    if (this.configuration.nosessionUrl) {\n      const router = this.injector.get(Router);\n      router.navigateByUrl(this.configuration.nosessionUrl);\n    }\n  }\n}\n","import { Inject, Injectable, Injector } from '@angular/core';\nimport { HttpClient, HttpRequest, HttpHandler } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { BehaviorSubject, Observable, throwError } from \"rxjs\";\nimport { tap, catchError, filter, take, switchMap, finalize, share } from 'rxjs/operators';\n\nimport { StorageService } from 'factor-utils';\n\nimport { AuthProvider } from './auth-provider';\nimport { Token } from './models/token';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class OAuthService implements AuthProvider {\n  private loggedInSource: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);\n  public loggedIn: Observable<boolean> = this.loggedInSource.asObservable();\n  private refreshTokenInProgress = false;\n  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\n\n  constructor(\n    private http: HttpClient,\n    private storageService: StorageService,\n    @Inject('FactorAuthConfiguration') private configuration,\n    private injector: Injector\n  ) {\n    this.checkLoggedIn();\n  }\n\n  addAuthenticationToken(request): HttpRequest<any> {\n    const token: Token = this.getToken();\n\n    // If access token is null this means that user is not logged in\n    // And we return the original request\n    if (!token || request.url.includes(\"token\")) {\n      return request;\n    }\n\n    // We clone the request, because the original request is immutable\n    return request.clone({\n      setHeaders: {\n        Authorization: `${token.token_type} ${token.access_token}`\n      }\n    });\n  }\n  checkLoggedIn() {\n    if (this.getToken()) {\n      this.loggedInSource.next(true);\n    } else {\n      this.loggedInSource.next(false);\n    }\n    return this.loggedIn;\n  }\n  getToken(): Token {\n    return this.storageService.get('token', 'local');\n  }\n  handle401Error(request: HttpRequest<any>, next: HttpHandler): Observable<any> {\n    if (!this.refreshTokenInProgress) {\n      this.refreshTokenInProgress = true;\n      this.refreshTokenSubject.next(null);\n      return this.refreshToken().pipe(\n        switchMap((newToken: Token) => {\n          if (newToken) {\n            this.refreshTokenSubject.next(newToken);\n            return next.handle(this.addAuthenticationToken(request));\n          }\n\n          // If we don't get a new token, we are in trouble so logout.\n          this.logout();\n          return throwError('');\n        }),\n        catchError(error => {\n          // If there is an exception calling 'refreshToken', bad news so logout.\n          this.logout();\n          return throwError(error);\n        }),\n        share(),\n        finalize(() => {\n          this.refreshTokenInProgress = false;\n        }),\n      );\n    } else {\n      return this.refreshTokenSubject.pipe(\n        filter(token => token != null),\n        take(1),\n        switchMap(token => {\n          return next.handle(this.addAuthenticationToken(request));\n        })\n      );\n    }\n  }\n  login(form: { username: string, password: string }): Observable<Token> {\n    const params = {\n      client_id: this.configuration.clientId,\n      client_secret: this.configuration.clientSecret,\n      grant_type: 'password',\n      response_type: 'token',\n      username: form.username,\n      password: form.password,\n      state: Date.now()\n    };\n    return this.http.post(this.configuration.tokenUrl, params).pipe(tap((token: Token) => {\n      this.storageService.set('token', token, 'local');\n      this.loggedInSource.next(true);\n    }));\n  }\n  logout(): void {\n    this.storageService.delete('token', 'local');\n    this.loggedInSource.next(false);\n    if (this.configuration.nosessionUrl) {\n      const router = this.injector.get(Router);\n      router.navigateByUrl(this.configuration.nosessionUrl);\n    }\n  }\n  refreshToken(): Observable<Token> {\n    const token = this.getToken();\n    const url = `${this.configuration.tokenUrl}`;\n    const params = {\n      client_id: this.configuration.clientId,\n      client_secret: this.configuration.clientSecret,\n      grant_type: 'refresh_token',\n      refresh_token: token.refresh_token\n    };\n    return this.http.get(url, { params: params }).pipe(tap((token: Token) => {\n      this.storageService.set('token', token, 'local');\n      this.loggedInSource.next(true);\n    }));\n  }\n}\n","import { Inject, Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { tap } from 'rxjs/operators';\n\nimport { StorageService } from 'factor-utils';\n\nimport { JwtService } from './jwt.service';\nimport { OAuthService } from './oauth.service';\nimport { AuthProvider } from './auth-provider';\nimport { Token } from './models/token';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n  \n  constructor(\n    private http: HttpClient,\n    private storageService: StorageService,\n    private jwtService: JwtService,\n    private oauthService: OAuthService,\n    @Inject('FactorAuthConfiguration') private configuration\n  ) {\n    this.getProvider().checkLoggedIn();\n  }\n\n  getProvider(): AuthProvider {\n    return this.configuration.type === 'oauth' ? this.oauthService : this.jwtService;\n  }\n}\n","import { Inject, Injectable, Injector } from '@angular/core';\nimport { HttpHandler, HttpRequest, HttpErrorResponse, HttpSentEvent, HttpHeaderResponse, HttpProgressEvent, HttpResponse, HttpUserEvent } from '@angular/common/http';\nimport { Observable, BehaviorSubject, throwError } from 'rxjs';\nimport { catchError, filter, take, switchMap, finalize, share } from 'rxjs/operators';\n\nimport { AuthService } from './auth.service';\nimport { Token } from './models/token';\n\n@Injectable()\nexport class AuthInterceptor {\n  private authService: any;\n  private refreshTokenInProgress = false;\n  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\n\n  constructor(\n    private injector: Injector,\n    @Inject('FactorAuthConfiguration') private configuration\n  ) { }\n\n  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpSentEvent | HttpHeaderResponse | HttpProgressEvent | HttpResponse<any> | HttpUserEvent<any> | any> {\n    this.authService = this.injector.get(AuthService);\n    return next.handle(this.authService.getProvider().addAuthenticationToken(request)).pipe(\n      catchError(error => {\n        if (error instanceof HttpErrorResponse) {\n          switch ((<HttpErrorResponse>error).status) {\n            case 401:\n              if (this.authService.getProvider().handle401Error !== 'undefined') {\n                return this.authService.getProvider().handle401Error(request, next);\n              } else {\n                this.authService.getProvider().logout();\n                return throwError(error);\n              }\n              break;\n            default:\n              return throwError(error);\n              break;\n          }\n        } else {\n          return throwError(error);\n        }\n      })\n    );\n  }\n\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nimport { AuthInterceptor } from './auth-interceptor';\n\n@NgModule({\n  declarations: [],\n  imports: [],\n  exports: []\n})\nexport class AuthModule {\n  public static forRoot(configuration: any): ModuleWithProviders {\n    return {\n      ngModule: AuthModule,\n      providers: [\n        { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },\n        { provide: 'FactorAuthConfiguration', useValue: configuration }\n      ]\n    };\n  }\n}\n","\nimport { Inject, Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n\n  constructor(\n    private authService: AuthService,\n    @Inject('FactorAuthConfiguration') private configuration\n  ) { }\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {\n    if (this.authService.getProvider().getToken()) {\n      return true;\n    } else {\n      this.authService.getProvider().logout();\n      return false;\n    }\n  }\n}\n","import { Inject, Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LoginGuard implements CanActivate {\n\n  constructor(\n    private authService: AuthService,\n    private router: Router,\n    @Inject('FactorAuthConfiguration') private configuration\n  ) { }\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {\n    if (this.authService.getProvider().getToken()) {\n      this.router.navigateByUrl('/');\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n"]}