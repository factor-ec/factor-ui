{"version":3,"sources":["ng://factor-auth/lib/auth.service.ts","ng://factor-auth/lib/auth.guard.ts","ng://factor-auth/lib/login.guard.ts","ng://factor-auth/lib/auth-interceptor.ts","ng://factor-auth/lib/auth.module.ts"],"names":["AuthService","http","injector","storageService","configuration","this","loggedInSource","BehaviorSubject","loggedIn$","asObservable","router","get","Router","prototype","login","form","redirect","_this","params","client_id","clientId","client_secret","clientSecret","grant_type","response_type","username","password","post","tokenUrl","pipe","tap","token","set","localStorage","next","navigate","logout","delete","getToken","refreshToken","url","refresh_token","Injectable","args","providedIn","HttpClient","Injector","StorageService","Inject","AuthGuard","authService","canActivate","state","LoginGuard","navigateByUrl","AuthInterceptor","refreshTokenInProgress","refreshTokenSubject","intercept","request","handle","addAuthenticationToken","catchError","error","HttpErrorResponse","throwError","status","handle401Error","filter","take","switchMap","newToken","share","finalize","includes","clone","setHeaders","Authorization","token_type","access_token","AuthModule","forRoot","ngModule","providers","provide","HTTP_INTERCEPTORS","useClass","multi","useValue","NgModule","declarations","imports","exports"],"mappings":"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","sourcesContent":["import { Injectable, Injector, Inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { tap } from 'rxjs/operators';\n\nimport { StorageService } from 'factor-utils';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n  private loggedInSource: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);\n  loggedIn$: Observable<boolean> = this.loggedInSource.asObservable();\n  router: Router;\n\n  constructor(\n    private http: HttpClient,\n    private injector: Injector,\n    private storageService: StorageService,\n    @Inject('FactorAuthConfiguration') private configuration\n  ) {\n    this.router = injector.get(Router);\n  }\n\n  login(form: any, redirect?: string) {\n    const params = {\n      client_id: this.configuration.clientId,\n      client_secret: this.configuration.clientSecret,\n      grant_type: 'password',\n      response_type: 'token',\n      username: form.username,\n      password: form.password\n    };\n    return this.http.post(this.configuration.tokenUrl, params).pipe(tap((token: any) => {\n      this.storageService.set('token', token, localStorage);\n      this.loggedInSource.next(true);\n      if (redirect) {\n        this.router.navigate([redirect]);\n      }\n    }));\n  }\n  logout(redirect?: string) {\n    this.storageService.delete('token', localStorage);\n    this.loggedInSource.next(false);\n    this.router.navigate(['/login', redirect ? { redirect: redirect } : {}]);\n  }\n  getToken() {\n    return this.storageService.get('token', localStorage);\n  }\n  refreshToken(): Observable<any> {\n    const token = this.storageService.get('token', localStorage);\n    const url = `${this.configuration.tokenUrl}`;\n    const params = {\n      client_id: this.configuration.clientId,\n      client_secret: this.configuration.clientSecret,\n      grant_type: 'refresh_token',\n      refresh_token: token.refresh_token\n    };\n    return this.http.get(url, { params: params }).pipe(tap((token: any) => {\n      this.storageService.set('token', token, localStorage);\n    }));\n  }\n}\n","\nimport { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n\n  constructor(\n    private authService: AuthService\n  ) { }\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {\n    if (this.authService.getToken()) {\n      //TODO Verify session on server with Observable\n      return true;\n    } else {\n      this.authService.logout(state.url);\n      return false;\n    }\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LoginGuard implements CanActivate {\n\n  constructor(\n    private authService: AuthService,\n    private router: Router\n  ) { }\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {\n    if (this.authService.getToken()) {\n      this.router.navigateByUrl('/');\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n","import { Injectable, Injector } from '@angular/core';\nimport { HttpHandler, HttpRequest, HttpErrorResponse, HttpSentEvent, HttpHeaderResponse, HttpProgressEvent, HttpResponse, HttpUserEvent } from '@angular/common/http';\nimport { Observable, BehaviorSubject, throwError } from 'rxjs';\nimport { catchError, filter, take, switchMap, finalize, share } from 'rxjs/operators';\n\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class AuthInterceptor {\n  private authService: AuthService;\n  private refreshTokenInProgress = false;\n  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\n\n  constructor(\n    private injector: Injector\n  ) { }\n\n  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpSentEvent | HttpHeaderResponse | HttpProgressEvent | HttpResponse<any> | HttpUserEvent<any> | any> {\n    this.authService = this.injector.get(AuthService);\n    return next.handle(this.addAuthenticationToken(request)).pipe(\n      catchError(error => {\n        if (error instanceof HttpErrorResponse) {\n          switch ((<HttpErrorResponse>error).status) {\n            case 401:\n              return this.handle401Error(request, next);\n              break;\n            default:\n              return throwError(error);\n              break;\n          }\n        } else {\n          return throwError(error);\n        }\n      })\n    );\n  }\n  handle401Error(request: HttpRequest<any>, next: HttpHandler) {\n    if (!this.refreshTokenInProgress) {\n      this.refreshTokenInProgress = true;\n      this.refreshTokenSubject.next(null);\n      return this.authService.refreshToken().pipe(\n        switchMap((newToken: any) => {\n          if (newToken) {\n            this.refreshTokenSubject.next(newToken);\n            return next.handle(this.addAuthenticationToken(request));\n          }\n\n          // If we don't get a new token, we are in trouble so logout.\n          this.authService.logout();\n          return throwError('');\n        }),\n        catchError(error => {\n          // If there is an exception calling 'refreshToken', bad news so logout.\n          this.authService.logout();\n          return throwError(error);\n        }),\n        share(),\n        finalize(() => {\n          this.refreshTokenInProgress = false;\n        }),\n      );\n    } else {\n      this.refreshTokenInProgress = false;\n      return this.refreshTokenSubject.pipe(\n        filter(token => token != null),\n        take(1),\n        switchMap(token => {\n          return next.handle(this.addAuthenticationToken(request));\n        })\n      );\n    }\n  }\n  addAuthenticationToken(request) {\n    const token = this.authService.getToken();\n\n    // If access token is null this means that user is not logged in\n    // And we return the original request\n    if (!token || request.url.includes(\"token\")) {\n      return request;\n    }\n\n    // We clone the request, because the original request is immutable\n    return request.clone({\n      setHeaders: {\n        Authorization: `${token.token_type} ${token.access_token}`\n      }\n    });\n  }\n\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nimport { AuthInterceptor } from './auth-interceptor';\n\n@NgModule({\n  declarations: [],\n  imports: [],\n  exports: []\n})\nexport class AuthModule {\n  public static forRoot(configuration: any): ModuleWithProviders {\n    return {\n      ngModule: AuthModule,\n      providers: [\n        { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },\n        { provide: 'FactorAuthConfiguration', useValue: configuration }\n      ]\n    };\n  }\n}\n"]}